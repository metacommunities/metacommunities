# Code-traffic: how software repositories express urban life

Adrian Mackenzie
Sociology Department, Lancaster University
a.mackenzie@lancaster.ac.uk


> The initial step can be made through the venerable geographical act of mapping the expanding realm of machinekind, clearly part of the remaining terra incognita. [@Horvath_1974, 188]

Writing in 2002, Nigel Thrift and Shaun French asked: 'is there any way of making a more general assessment of software in the city?' [@Thrift_2002,  314].  They sketch some possibilities, ranging from hegemony to haunting:

> It would be easy at this point to fall back on some familiar notions to describe software's grip on spaces like cities. One would be hegemony. But that notion suggests a purposeful project, whilst software consists of numerous projects cycling through and continually being rewritten in code. Another notion would be haunting. But again the notion is not quite the right one. Ghosts are ethereal presences, phantoms that are only half- there, which usually obtain their effects by stirring up emotions – of fear, angst, regret, and the like [@Thrift_2002, 311-312].

Thrift and French's empirical response to their own question begins with the Y2K bug, and the long lists of software potentially affected by it: keypad locks, pagers, solar panels, smoke detectors, camcorders, VCRs, elevators. Although these lists now look dated, when a similar listing would include so many  things that didn't exist in 2002, Thrift and French's description of the effect of software development on urban space remains recognisable: 'we will exist in a broadband world in which the internet will be a permanently available ‘cloud’ of information able to be called up through a number of appliances scattered through the environment. These appliances will be something more than portals for information. Rather, like many other devices which will not have internet connections, they will be "practice-aware"' (315) and 'will, through a process of cultural absorption into practices, sink down from the representational into the non- representational world, so becoming a part of a taken-for-granted set of passions and skills' (318). The fact that these developments more than a decade later are still very much in train suggests that there is something quite predictable about the development of software and coding in organising urban life and spaces.  

They go to  list three geographies that were driving code into cities: a geography of *writing code*, a geography of *power and control*, and a geography of *indeterminancy.*  

>  The first of these geographies is the most obvious, the large and complex geography of the writing of software – of the production of lines of code – a geography that takes in many different locations and many different languages and which has been built up progressively since the invention of programming in the 1940s [@Thrift_2002, 323].

According to Thrift and French, the geography of software writing clusters around  key places and regions: Silicon Valley, New York, London, and a number of auxiliary software mass production zones (often concentrating on tasks like consulting, testing and support) in countries like Ireland and India. China, Russia and Brazil are not mentioned.  

A second less concentrated geography of power, conceived in Foucaultean terms as the conduct of conduct, or massive proliferation of corporeally practiced rules, was also  unfurling through software: 'in essence, we can say that it [software] consists of rules of conduct able to be applied to determinate situations' [@Thrift_2002, 325]. Through power-geography, software increasingly interlinks rather than compartmentalises urban processes. (Again,  the ongoing growth of data analytics, virtualizing computing infrastructures, social media, mobile apps and sensors is largely consistent with this analysis of power.)

A  final geography was the most open and the least geographically localised. In this geography, abundance produces indeterminacy and lack of closure:

> the general profusion of software, its increasing complexity and consequent emergent properties, all count as means of producing playful idioms that have not been captured by dominant orders. Software's very indeterminacy and lack of closure provide a means of creating new kinds of order (328). 

These playful idioms are largely irreducible to the centres of coding or power-generated control practices, and therefore will take on singular forms, unexpected locations and non-representational aspects. Where or how does the geography of indeterminacy take shape? Against various attempts to see software and code as either hegemonic, as law, as an epochal shift, as what has always haunted writing, or as the epitome of the post-human technics, Thrift and French sketched  the phenomenality of code  as a form of traffic: 

> Software is more like a kind of traffic between beings, wherein one sees, so to speak, the effects of the relationship. What transpires becomes reified in actions, body stances, general anticipations. We would argue, then, that software is best thought of as a kind of absorption, an expectation of what will turn up in the everyday world.[@Thrift_2002, 312]

These formulations are the most elliptical in the paper.  But the 'traffic between beings' they refer to here, the reification of 'general anticipations,' the curiously contrasting descriptions of software as absorption _and_ expectation could be seen as implicitly urban. They concern 'traffic' in everyday worlds. 

More than a decade later, these geographies remain in play. Code work is done in more or less the same places; and the coded conduct of conduct certainly continues. But when  we think about code in terms of traffic, what has happened to it? What kinds of new order have eventuated? Writing in 2014, Thrift again asks addressed coded cities: 'Take just the case of coded cities understood as a whole,' [@Thrift_2014, 13], and then proceeds to offer a sixfold topography of the code city - as externalization of capitalist power,  as prescribed matter of concern, as care-laden responses to the demand for resilience, as projected-retrojected dream life, as navigational geometry, and as materialized visualisation. He finally suggests that something links this diversity: the possibility for 'these entities to learn ... to transform themselves.'   Echoing the 2001 discussion of the geography of indeterminacy, he attributes this possibility to 'emergent tendencies arising out of complexity' or 'through simple happenstance which places them in unexpected situations which require adaptation' (13). 

The sixfold evocation of the coded-city proliferates the geographies of software in the city, but it reiterates the same kinds of transformative capacity earlier enunciated in the geography of indeterminacy.  The 2001 formulations on indeterminacy and 'traffic in beings' grow into forms of novel encounter in 'unexpected situations.' (While urban sociology has long understood cities in terms of encounters between strangers, Thrift's account shifts the emphasis to unexpected encounters between other beings.)  Coded cities' 'capacity to learn' transpires, according to this account, in elementary forms of movement understood as *code traffic.* The 'authoring,' the 'learning', and the transformations should not only be traceable in code, but coding itself is one place where externalizations, matters of concern, geometries,  projections, visualizations, resilience-care, etc. come together and affect each other.  The  'traffic between beings' moves and  mixes along various paths  through what we might understand,  drawing on crowd sociologists  such as Gabriele Tarde and Robert E. Park, as processes of _imitation_. For both Tarde the microsociologist of crowds and Park the urban sociologist,  imitation powerfully yet semi-consciously effects repetition and invention, and generates new social forms of various kinds [@Borch_2012]. In particular, Tarde speaks of  'coadaptation of imitative fluxes, a cooperation, even in an individual brain, but always a multitude of agents social and infinitesimal, and their ordinary ideas' [@Tarde_1902, 270]. While there is much to discuss here (for instance, Tarde's political conservatism and anachronism poses analytical problems), the 'coadaptation' of imitations in combination with a  multitude of infinitesimal agents, beneath and around individuals, resonates with the idea of code as ontological traffic, as transient pluralities whose coagulations and diffusions may play out in control structures, in architectures, in matters of concern, etc.  Examining patterns of imitation in code moves the emphasis away from code-shaping-cities to code-as-crowd. In the code-crowd, imitation is not just follow-the-leader, although this is quite prevalent, but also mutual shaping of imitative fluxes running between people and machines in places.[^1]

[^1]: This, I should note, is a departure from most crowd theory, crowd psychology and crowd sociology. In most cases, objects hardly figure at all. As I will sketch below, points of identification occurs between systems, platforms, protocols and patterns just as much as  between individuals. 

To treat *code-traffic* in terms of crowd sociology as co-adaptation of imitative fluxes is  not to deny the production and power geographies of code. It is not to say that code does not still act on cities, on space, on public and private practices.  High profile and much discussed changes taking place in computational platforms (mobile devices, cloud, etc.) and in algorithmic processes (machine learning) intricately reorganise urban life. What transpires there is rapidly reified in actions, body stances, etc.   But it might also be worth seeing how code has become a mixing process, re-configuring the architectures, the buildings, the logistics and diffuse circulation of individuals in cities. We would, from this standpoint, no longer concentrate on following how software emanates from global production centres  as hierarchical or supervisory control structures  reorganizing cities.  Furthermore, we would no longer focus on isolated pieces of software, systems or applications but on the transverse flows that change how code itself moves and takes shape. We would apprehend coding itself as something closer to pedestrian and vehicle movements in a busy street in which branching, merging, starting, turning and stopping compose transient multiplicities adapted to particular problems and situations. That is to say, we might attempt to see code as  noisy, crowded, propagating aggregates in which juxtapositions, proximities and patterns of imitation multiply through each other. 

## `git` as code traffic: dangerous coagulation or regularized order?

The study of code-traffic poses some empirical problems, but we can glimpse some of the traffic in code via increasingly important code repositories. A huge number of code repositories (possibly around 50 million) are now hosted publicly online at code repository sites such as GitHub.com, Bitbucket.com, code.google.com and SourceForge.com.  Focusing on one of these repository hosting platforms -- GitHub.com, allegedly the 'largest code repository on planet' -- might be a way to begin to find a way of beginning to see traffic in code, and to track how co-adaptive, infinitesimal fluxes flow.[^3]  Code moves in and out of these repositories in many different ways. This movement is not logistically or hierarchically controlled. It constitutes a vast, complex reticular movement. Much of the flow of source code passes through a single piece of software called [git](http://git-scm.com/).  `git`, an English word for a male person who acts foolishly or annoyingly (often in a crowd), was chosen by Linus Torvalds in 2005 as the name for a new concurrent versioning system for source code. In 2002, Torvald's work on GNU/Linux  epitomised for many people the emergent power of open source collaboration -- 'crowd-sourcing' -- on the internet to build things outside the geographies of the software industry.  (But even then, as Thrift and French observed,  Linux was a quite centralised hierarchically and industry-supported software project). In turn, the `git`    a revision control system for code that allows incremental changes made by many people working a common software project to merge with or diverge from each other. `git` is today probably the most widely used revision control system for code ( by the interestingly named `subversion`). In practice, a whole series of converging and diverging movements of cloning, forking, pulling, pushing, requesting, branching and merging comes out of `git`. Often used on commandline, commands such as

>`git clone
>git commit
>git push
>git pull
>git branch
>git merge`

suggest some of the elementary movements that generate code traffic in and out of the millions of repositories.   For instance, some `git` commands replicate whole bodies of code, while others simply add, remove or alter small bits of code. These scale-variations, I would suggest, matter to the flows of imitation that occur. Movements of code can take place very incrementally, as small bits of code move around and they can take place on a large-scale as whole bodies of code travel between different bits of software. `git` as a contemporary site of coding merits much more empirical description than this, but for the present purposes `git` represents the distributed cycling and re-writing traffic in code. These movements, while certainly not unique or unprecedented in the history of inscriptive techniques, record-keeping system or archives, have become chained and interlinked in recent coding cultures in ways that generate the rapid transformations associated with many millions of code projects. 

[^3]: It might also be a way of undermining the over emphasis on algorithms that  blocks light, I would suggest, on the richer cultural and social traffic in code forms.

We should note that Torvald's intention in writing `git` was to radically de-centralise code repositories in the sense that no particular of a repository would be the 'master' or hub.  In principle, a decentralized network of repositories  'push' and 'pull' code to each other. Different repositories would clone and branch off from each other, and occasionally would merge again, but not necessarily.  The geography of coding would become less aligned to individual developers in specific times places and times, and more open to a range of different styles of  code movement, ranging from an uncontrollably fluxing miasma of micro-projects through to vast hierarchical code architectures. Torvalds did not reckon with the increasingly social coding of coding. Since late 2007, GitHub has provided  a  hosting platform for many git repositories, and now attracts the largest share of code traffic of any code repository.  From the perspective of  the `git` software, GitHub is just another remote  code repository. But given that many, in fact around 13 million, local `git` repositories have GitHub.com as their remote repository, then GitHub becomes a hub for `git.` The network and code traffic that now runs through GitHub is on the scale of a mid-size social media platform. That is, with 13 million repositories, 6 million developers, and around 250 million events in the public event stream, GitHub itself is a kind of code terminus, whose functioning, architecture, and machinery symptomatically enunciates contemporary code traffic more generally. 

## Github as a `git` terminus


